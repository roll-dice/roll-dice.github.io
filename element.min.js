"roads-technology.nl"  = = location.ho st  && console.log("This code is a mess, but it work s");  v ar  e = 0 ; import * as t from "https://cdn.skypack.dev/c annon- es"; impor t *as o from "./dependencies/t hree.m in.js"; im port *as a from "./dependencies/BufferGe ometryUtils.js"; customElements.de fine("roll-dice", class e x tends HTMLElement {   connectedCallb ack() { Math.r a ndom(); this.innerHTML = '<canva s id="canvas"></can vas>', O bj ect.assign(thi s,  funct io n ({ cu st omElement: t, THREE:   o,   CANNO N : a, BufferGeometryUti l s : n }) { t.log = t.hasAt tribu t e(" l o g") ,  e = t.hasAttribut e( " de bug " ) ; var i = (e, o = !1) => t.getAttr i bute(e )  || o ||   ! 1 , r = document.querySelect o r ("#canvas"), { width: s, height: l }  =   r. g etBoundingClientRect(), c = t.p a r entNode. getBoundingClie n t Rect(), d = (c  =   r .g et B o undingClientRect ()) . t op, h =   ( c. l e ft ,   r. o f f se t W idt h) , m   =  r. o f f s et H eig h t ,   u  =  e  & &  1,   y  = ~~i("diceco unt", 5),   p  = void 0, g = 5, v =  1, w = 40 + 5  *   g, x = [0, g, v], M  = -1, z  =   w / 10 - .5,  b = w / 1 0   - .5,   f  =  [ ] , S  =   i("d i c ecol o r ",   " wh i t e " ),   E  = i (" dic esel ec tedc olo r" , "l ight gr een "),  A  = i ( " di c e ho v e rco lor" , "bei ge"),  P = i ("do tcolo r",  "bl ac k") , T = . 485 , q  =  28,  B =  .13 , I  =  .13, L  = .13,  k  = 6 , N =  2,  C = k /  2 ,  j  = [[ 0,  k,  0],  [ -N,  k,  - N] , [ N, k ,  -N ],  [- N,  k,  N ],  [ N, k, N ]], G  = 4 , H  = 1,  R =  [0, [0],   [ -.7 5, .75 ],  [-1.2 , . 25 , 1 .7],  [- 1,  -1,  1, 1 ],  [ [- 2.5 , -1,  .5, 2 , 3.5 ], [- 1, -1, .5,  2,  2]] [H] ,  [- 1.75, 0 ,  1 .7 ,   -1 . 7 5,   0, 1.7]][y], F  =  [0, [8], [6, 6], [6,   6,  6], [6, 6, 6, 6], [[6,  6 ,  6,  6, 6 ],  [ 7 , 7, 7, 7,   7 , 7]][H],  [ 6 .5, 6.5, 6 .5, 6 . 5, 6.5, 6 .5]][ y ] , O = [0, [1. 5],  [ 1 , 1.5], [1, 1,  1],   [ -.5, 1, 1, -. 5],   [ [1,  1 , 1 ,   1, 1], [.125, 2. 25,   1 .25, 2.25, .125]] [H],   [ .5, .5, .5, 2, 2 , 2] ] [ y] ,  [ V = 0 ,  X = 0 ,   Y =  0] = ( i ("al ig n dice ")   ||   "0 , 0 ,0 " ) .s pl it(","); e && co ns ole .w a rn ( "a l i gn e d ",  R , F, O, "\n",  V );  V  =   Nu mber(V), X = Nu mb e r (X ), Y = Number( Y) ;   va r Z = i("mass ",   1. 5) ,  W = i("gravi ty x" ,  - 4 ),   Q  = -i("g r avity y", 50),   U = i("gravit y z", 0 ) , D =   [ W, Q,  U ], J  =   i("diceimpu l s e", 5), K =   i ("di cerot at ion",  .6), $ =  i(" resti tution", .6), _  =  3;  e && (D[1] =  - 550 ); $ = .06 ; var ee = 3e3 , te = 5e3, oe = (e   = 0,  t  = 0,  a  =  0)   =>  n e w o . Ve ctor 3( e,  t ,  a ),   ae  =  ( e =  0,  t  =   0,  o   = 0 )  = > ne w  a.Vec3( e,  t ,   o),  ne   =  e = >  n e w a. World( e ) ,  ie = e  = >  new  a. Bo dy (e ) , re = e => ne w  a. Box(e), se = ( )  => { he.render ( me,  v) } , le  =  e  = >  e *  ( Math.PI / 180); c lass ce { cons tr uctor() {  va r   e = this, a = e.mesh = be(), n =  a.positio n, i = a.rotation, r = ie ( { mass: Z, shap e : r e(ae(.5, . 5, .5)), sleepTimeL imi t :  .1  } );  th i s. animating = !1, me .a dd(a), de.addBody(r), Objec t.ass ign(this,  { mesh: a,  body :  r, X:  (e  = 0)  = > {  n .x = e,  se ()   } ,  Y: (e  =   0 )  =>   { n.y =   e,  s e () }, Z: (e =  0 ) => { n.z =  e, s e () }, moveTo: ({ x:  e  = n.x, y: t = n.y, z: o = n.z, speed: a  = 1, vector: i =  oe(e, t, o) } )  = > { this.anim at ing   = !0,  setT im eo ut ((()  = > this.animating =  !1 ),  e e );  va r s  =  ()  = > { var  l  =   i.clone().sub ( n); this.animat ing && l.l e ngth() >= 1 ?   ( l .n ormalize().mu lt iplyScalar(a),  n.add(l), request An imationFrame( s )) : (this.animating = !1, n.copy(i), r. p osition.copy(i),  n .x = e, n.y = t , n.z = o, custo mEl ements.log && console.warn( " done moveTo",  r.i d,  "val ue :", this. va lu e ,  "P: ",   n , "\ n" ,   l)),  se()  } ;  s( )  },   toFloor: ({ y: e =  0 , delay: t = 0  } ) = > { c o nst o = () => { this.animating ? setTimeout(o,  10 0 ) : (c ust o mEleme nts . log &&  cons o le .e r ror ( "w ai t  fo r  a n i mating false", this.animating), setTimeout((()   = > { this.moveTo ( {  x:  n .x  +  [ -1 .5, -.5 ,   0 ,  1 ,  2 ,  2.5, 3, 3.3][th is. sortidx],   y: e,  z:  0 })  }) , t)) } ; o() },  s elec t:  ()   => { this.sele c te d =  ! thi s .selected, thi s .c olo r  = t h is.selected ?  E  :  S, this.moveTo({ x: (thi s .selected,  R[t hi s.s or tidx]) ,  y:   this.selected ? Nu mb er(t.getAttribute("se lected height")) : F[this.sortidx], z:  ( thi s .s elected, O[thi s .so r ti dx]) }), t.dis p atc h ("d ic e- select ed ",   { sel e ctedd ice: this }), se()  } , rotateTo: ({ x: e = i.x , y: t  = i.y, z: n   = i .z, s p eed:  r = .05 }) => { customEl ement s .lo g   & &  console.log ( e,   t ,  n ); var s =   (n e w o.Eule r ). s e t Fr omQuaternio n (a.quat e rn i on ) ;   s. x = le(e), s.y =   le ( t ),  s.z = le(n); va r  l   =  ( )  = >  {  va r  { x: e, y: t, z:  n  } = (new o.Euler).setFrom Quate rn ion(a.qua ternion), c  =  ne w o.Euler (s . x   -  e , s.y -   t,  s.z - n,   "XY Z"), d = e = >   e  >= r && console.w ar n(e, r ) ; anim a ting   = d(c. x ) ||   d(c.y)   || d ( c.z),  a nima t ing ? (i.x += c.x =  M ath.si g n(c. x ) * r,   i.y  + = c.y = Math.sign(c. y )  *  r, i.z += c.z  =  Math. sig n( c. z)  *  r ,  requestAnimat i onFrame(l)) : i.copy(s), se() }; l()  } , nudge: ()   => { customElements.log &&   console.war n ("nudge" ,  e.id ) , r.applyImpul se(ae((Math.rand o m() - .5) *  _,  (Math.random()  -  .5) * _, (Math.random() -   .5) * _), n) } , slee p :  ( ) => {   v ar e = thi s;   custo m Elements.log && console.lo g (" s l eep dice", r.id), r.allowSlee p  = !1; var   t   =  ae();   r.qu aternion.to Eul er(t); v ar o = . 1,  n = e => Math.abs(e) < o, i = e => Ma t h. abs(e  -  .5 * Math.PI) < o, s  = e = > M ath.abs(.5  *  Math.PI   + e ) < o, l = e => Math . abs (Math.PI - e) < o || Math.abs(Math.PI + e) < o, c  = (t  = "")   => { customE l e ments.log && console.warn( "nudge die " , r.id, t, e .val ue),  r.allowSleep = !0, e.nudge() }, d = t = > { e.value  =  t,  e.ro lling  =  !1, a.position.y > 1 && c(" stac ked dice")  }; n(t . z) ? n(t.x) ? d(1) : i(t.x ) ?  d(4) : s(t.x) ? d( 3)  :   l(t .x) ? d(6) :  c ("l anded on edge1") : i(t. z ) ? d (2) : s(t.z) ? d(5) : c( " lande d on egde2") } }) } g e t s ideorder() { return  [ 2, 5,  1, 6, 3, 4 ] } g e t  material() { return this .m es h .chil d ren[1].mat e ri a l }   get col or() { return thi s.material.color } set color(e =  " wh ite") { var  t  = t his.ma t erial; Array.isA r ra y(t) ? t.forEach((t => t.col or.se t(e)) ) : this.material.color.set(e) }  colo rByValue({ color: e = S, valu e:  t = this.value }) { var o = t his. sideor d er.indexOf(t); t && o ? this.materia l[ o] .color.set( e ) :  this.color = e   } } v a r de = ne ( {   a l lo w S leep: !0, g r av i t y :   ae ( . ..D)  }) ; de . de faultContactMaterial.re stitution  =  $;  v ar  he = new o.WebG LRenderer({ alpha:  !0, antialias: !0, canvas: r } ); he . s ha d o wM ap.enabl e d = !0, he . s e tP ixelRatio(M a th.m i n (windo w. devicePixel Ra t io , 2)); var me = new o.Scene; v = ne w o.PerspectiveCam er a(w, i n n er Width / inn e rHe ight, . 0 1,  30 0 ),   v. posi tion.set(. . .x).multiplySc a lar(2), v . lookAt(0, 0, 0) ,  Ee(); var  ue =  new  o .AmbientLight ( 167772 15 ,   .5);  me.ad d( ue);  var  ye  =  new o. Po intLight(167 77 21 5 , .5) ;  ye. posit i on. set(0, 25, 2 * z),  ye .cast Shadow = !0, ye.sha dow.mapSize.wi dth =   2048,   y e.shadow.mapSize.height = 2048 ,  y e. sha dow.camera.near = .1, ye. s h adow.c amera.far  = 1400 , me .add(ye), xe( ), f = Array (y) .fill(0) .m a p ( ((e, t)  =>  { var o = w in dow[ "d "  + ( t  +   1)]  =   new c e ; return f.push(o ), o.body.addEventListen er ("s leep",  ( e = > o.sleep()) ) , o })) ;  v ar pe = new o.Raycas t er; u && me.add(new o.Axes Helper(z)); we(), Ae(), window.a ddEventLi s te ner("resiz e ",  E e), t.hasAttr i bute( " dou b l eclick") && t.addEventListener("d blc lick", Ae); let ge = d ocument. q uery Selector("#roll - btn "); ge && (g e .o nclick = Ae); function ve(t) { var o  =  t. cl i entX / s  * 2 - 1, a  = -( t .cli entY  - d) / l * 2 +  1, n  = oe(o, a,  .5) ; e && console.warn(t.client X, t.clientY, s, l, o, a), n.unp roject(v), pe . set(v.positio n , n .sub(v . po s i tion).normalize());  va r  i  =  e = >   { e && (e.color = e.se l e ct e d  ?   E  :   S, e.mou seov e r = ! 1 ), p = void 0 }; f.filter(( e = >   { if (pe.intersect Object(e.mesh). length) return e.mouseover || (i(p ) ,  p = e, e.mouseove r =  !0, e.color  =   A) , e; p == e & &   i( e) })).length   ?   r.style.cursor = "pointer" : (r.s t y le.cursor   = "inherit",  i ( p) ), se() } fun c t i on w e ()  { [ae(0, G, b - .75), ae(0, G,  -b) ,  ae ( b, G , 0 ) , a e (-b,   G, 0)].map((( t ,  n ) => { var i  =   i e({  m as s: 0 }); i.addShape(re(ae(z, z,  0)) ) , i . posi tio n .co p y(t) ,  de.addBody(i ) ;  v ar r = .001,  s   =  new  o .M esh(new o.BoxGeometry(5 * b, z,  r),   new   o.Me shB a sic M ateri al(e  ?   {  co lo r :  [ 1 6 711680,   65280, 255,  16776960][n ], t r a nsparent: !0 ,  opa c i t y:  .5 } :   { opacit y :  0,  tr ans par e nt:  ! 0 }));  if (2   == = n  ||   3 == =  n) { v a r  l =   new  a.Q ua ternio n ;  l.s e tFro m Ax isA ngl e (ae( 0,  1, 0) ,  M ath . PI /  2) ,  s.rotat ion.y  = M at h.PI /   2,  i. q uate r nio n.c opy ( l) }  r eturn  s .p osi t ion. cop y( t), s. q ua ter n ion. cop y( i.quat e rn ion ) , s. vis ib le = u ,  m e.a d d(s) ,  i  }))  }  f unct io n xe()   {  var   e =  .1,  t  = new   o. Mes h (new  o. Pl aneGeom etry(1 , 1 ),  new o . Sh ado w Mate ria l( { opac i ty : e   }));   t.r ece ive Sh adow  =  !0, t . po sit i on.y  =  M,  t.qua t er nion.s etF ro mAxisA n gl e(o e (-1,  0,  0 ), .5  *  M ath . PI),  me .a dd(t);   va r n =  ie( {  type:  a .B ody . STATI C, shape: n ew a .Pla ne } ) ; n.position.copy(t.position), n.qu aternion.copy(t.quaterni on ) , de.addBody(n) } function Me() { for (var  e   = 1, t = new  o .BoxG e ometry(e, e, e, q, q,   q ) ,  a   =   t.a ttributes.position, i = .5 - B, r = 0; r < a.cou nt ; r+ +) { var s = oe().fr o mBufferAttribute(a, r ),  l  = oe(Math.sign(s.x), M at h.s ign(s.y), Math.sign( s .z)).multiplyScalar(i ),  c  = oe().subVectors(s,   l); Math.abs(s.x) > i  &&  Ma th.abs(s.y) > i && M a th.abs(s.z) > i ? (c. nor mali ze( ) .multiplyScal a r(B),   s =   l .add(c)) : Math.abs(s.x) > i  && Mat h. abs(s.y) >   i ?  (c.z = 0, c.normalize().mul tiplyS ca lar(B), s. x  =  l.x + c.x, s.y = l.y + c.y)  : Math .a bs(s.x) >  i  &&  Math.abs(s.z) > i ? (c.y =  0, c.n or malize().m u lti plyScalar(B), s.x = l.x + c. x, s.z  =  l.z + c.z )  :  Math.abs(s.y) > i && Math.ab s(s.z)  >  i && (c.x   = 0,   c .normalize().multiplyScalar( B), s. y  = l.y + c. y,  s.z = l.z  +  c.z) ; var d = e  =>  ( e  *= 1 / I, e   =  Math.PI * Math. max ( - 1, Math.min(1, e )),  L * (Math.cos(e) +   1)) , h = e  =>  d ( e[0]) * d(e[1 ] ), m = .25; .5  === s . y ?  s.y -= h([s.x ,  s . z])  : .5   == = s.x ?  (s .x -= h([s.y + m, s.z + m]), s.x -= h([ s.y - m, s.z - m])) : .5 === s.z ? (s.z -=  h([s.x - m, s.y + m]), s.z -= h([s . x, s.y ]), s.z -= h([s.x + m, s.y   - m])) : -.5 === s. z  ? (s.z += h([s.x + m, s.y +  m]), s.z  +=  h ([s.x + m,  s.y -  m]), s.z += h([s.x - m, s . y + m]), s.z  + = h([s.x -  m,  s .y - m])) : -.5 = = = s.x ? (s.x += h([s.y + m, s.z  +  m] ) , s.x += h ( [s. y + m,  s .z  - m]), s . x  += h([s.y, s.z]),  s. x += h([s.y -  m, s.z +  m]), s.x += h([s .y - m, s. z  - m] ) )  :  -.5  = ==  s .y & &   (s .y  + = h([s.x + m,   s.z + m] ) ,   s. y += h([s.x + m, s.z]), s.y  += h([s.x +  m,  s.z -   m]), s .y  += h([s.x - m,  s . z + m ]),  s.y += h([s.x -   m , s . z]),   s .y  + = h( [ s. x - m, s.z - m])), a.setXYZ(r,  s. x,  s .y ,  s.z) } retur n  t.deleteAttribute("normal"), t .dele t eA tt r i bute("u v "), (t = n.mer geVertices(t)) .c om p ute V ertex No rmals ( ) ,  t  }  function ze () { var e = new o.P laneG eometry( 1 - 2 *  B, 1 - 2 * B); re turn   n.mergeGeometries( [e .clone().translate(0 , 0, - T), e.clo n e() .rotateY( . 5 *  Math.PI).translate(T , 0, 0), e.clone().translate (0,  0,  T ),   e.cl on e().r o ta te X(.5 * Mat h .PI). tr ans late(0, T, 0), e.clone().rot ateY(.5 * Math.PI). tr ansla te(-T, 0, 0), e.clone().rotateX( .5 * Math.PI).transla te (0,  -T,  0) ], !1 ) } function   be ( ) {  var  e  = !1, t = [new o.MeshStandardMaterial ({  c o lor:  S, w ireframe: e }), new o.MeshS ta nd a r dM aterial({  colo r : S,  wi refra me :  e  }), new o.Mesh Stand ardMat er ial({ c ol or: S, wireframe: e  } ), n ew o.MeshStandardM a t er ial({ color :  S, wirefra m e : e   } ) , new o.MeshSta ndard Mater ia l({ colo r: S,  wirefr am e:  e }), new o.Mes hS tandardMa te rial({  color: S, wireframe: e }) ], a = new o.MeshStandardMateri al ({  color: P, roughness: 0, metalness: 1, side: o.DoubleSide }), n  =  new o.G rou p, i = ne w o .Mesh(z e (),   a),  r = new o.Mesh(Me(), t); return r.castShadow  = !0, n.add(i, r), n } function fe()  { de.fixedStep(); var e  =  !0; setTimeo u t((() => e = !1), te),  e &&  f.map ((e => (e.me s h.position.copy(e . body.position), e.m e sh.quaternion. c op y (e.body.quaternion), e.rolling))).filter(Boolean).length ? (se(), requestAnimationFrame(fe)) : (customElements.log && console.log("done rolling", f.map(((e, t) => e.value))), Se(), t.dispatch("dice-rolled")) } function Se() { f.sort(((e, t) => e.mesh.position.x - t.mesh.position.x)).forEach(((e, t) => { e.selected = !1, e.color = S, e.sortidx = t, customElements.log && console.log(t, e.value, e.mesh.position), e.moveTo({ x: R[t] + V, y: F[t] + X, z: O[t] + Y }) })) } function Ee() { v.aspect = h / m, v.updateProjectionMatrix(), he.setSize(h, m); var t = oe(-1, 1, 0).unproject(v), o = oe(1, -1, 0).unproject(v), a = o.x - t.x, n = o.y - t.y; e && console.warn("updateSceneSize", a, n, t, o) } function Ae() { t.dispatch("dice-throw-start"); var e = () => 4 * Math.PI * Math.random(); f.forEach(((t, o) => { var { body: a, mesh: n } = t; if (t.selected) console.warn("hold", a.id, "value", t.value, t.mesh.position); else { customElements.log && console.log("throw", a.id), t.rolling = !0, t.hitwall = !1, a.velocity.setZero(), a.angularVelocity.setZero(); var [i, r, s] = j[o] || j[0]; i += C, a.position = ae(i, r, s), n.position.copy(a.position), n.rotation.set(e(), 0, e()), a.quaternion.copy(n.quaternion), a.applyImpulse(ae(-J, J, 0), ae(K, K, -K)), a.allowSleep = !0 } })), fe() } return r.addEventListener("mousemove", (e => { ve(e) })), r.addEventListener("click", (e => { p && p.select() })), { dice: f, roll: Ae } }({ customElement: this, THREE: o, CANNON: t, BufferGeometryUtils: a })), this.ondoubleclick = e => this.roll() } dispatch(e, t = {}) { t = Object.assign({ ...t, name: e, element: this, values: () => this.dice.map((e => e.value)) }, this), console.warn("%c event: ", "background:purple;color:gold", e, t), this.dispatchEvent(new CustomEvent(this.nodeName.toLowerCase(), { bubbles: !0, composed: !0, detail: t })) } }), console.log("<roll-dice> element.js loaded"), customElements.define("my-component", class extends HTMLElement { constructor() { super().attachShadow({ mode: "open" }).innerHTML = "<style></style>" } connectedCallback() { this.innerHTML = "" } });